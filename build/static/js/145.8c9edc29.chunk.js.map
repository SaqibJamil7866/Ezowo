{"version":3,"sources":["views/extensions/access-control/index.js","../../../src/Can.ts","utility/context/Can.js","../../../src/factory.ts"],"names":["AccessControl","ability","useContext","AbilityContext","md","sm","tag","className","can","noop","renderChildren","Fragment","children","length","createElement","Children","only","Can","_isAllowed","_ability","n","_unsubscribeFromAbility","componentWillUnmount","_connectToAbility","this","on","_this2","forceUpdate","_canRender","props","subject","of","a","an","not","I","do","field","render","passThrough","_renderChildren","elements","PureComponent","Getter","createContext","Consumer"],"mappings":"iGAAA,2CAsCeA,UA7BO,WAEpB,IAAMC,EAAUC,qBAAWC,KAC3B,OACE,eAAC,KAAD,WACE,cAAC,IAAD,CAAKC,GAAG,IAAIC,GAAG,KAAf,SACE,cAAC,IAAD,UACE,eAAC,IAAD,WACE,cAAC,IAAD,CAAWC,IAAI,KAAf,oBACA,cAAC,IAAD,uDACA,cAAC,IAAD,CAAUC,UAAU,eAApB,oEAILN,EAAQO,IAAI,OAAQ,aACnB,cAAC,IAAD,CAAKJ,GAAG,IAAIC,GAAG,KAAf,SACE,cAAC,IAAD,UACE,eAAC,IAAD,WACE,cAAC,IAAD,CAAWC,IAAI,KAAf,uBACA,cAAC,IAAD,gFACA,cAAC,IAAD,CAAUC,UAAU,cAApB,yDAIJ,U,ynBCtBV,IAAME,EAAO,aACPC,EAAiBC,WACnB,SAACC,UACIA,EAIEA,EAASC,OAAS,EACrBC,8BAAcH,WAAU,aAASC,IACjCG,WAASC,KAAKJ,GALT,MAOTG,WAASC,KA8BAC,qGAMoCR,OANpCQ,0CAIHC,GAAsB,IACtBC,EAAqB,KAAAC,EACrBC,EAAuCZ,IANpCQ,OAMoCR,kBAqBjCS,OArBiCT,EAE/Ca,qCACOD,OAGCE,EAAR,SAA0BtB,cACpBA,IAAYuB,KAAKL,SAIhBE,SACAF,EAAW,KAEZlB,IAAS,KACNkB,EAAWlB,OACXoB,EAA0BpB,EAAQwB,GAAG,WAAW,kBAAMC,EAAKC,sBAQ5DC,EAAR,eACQC,EAAaL,KAAKK,MAClBC,EAAUD,EAAME,IAAMF,EAAMG,GAAKH,EAAMI,IAAMJ,EAAML,MAAQK,EAAMJ,GACjEjB,EAAMqB,EAAMK,IAAM,SAAW,aAE5BL,EAAM5B,QAAQO,GAAKqB,EAAMM,GAAKN,EAAMO,GAAIN,EAASD,EAAMQ,UAGhEC,kBAEyBV,OAFzBU,KACOf,EAAkBC,KAAKK,MAAM5B,cAC7BiB,EAAaM,KAAKI,IAChBJ,KAAKK,MAAMU,aAAef,KAAKN,EAAaM,KAAKgB,IAAoB,QAGtEA,EAAR,iBACgChB,KAAKK,MAA3BjB,aAAUX,YACZwC,EAA+B,oBAAb7B,EACpBA,EAASY,KAAKN,EAAYjB,GAC1BW,SAEGF,EAAe+B,I,8CAAAA,uBAxBxB,kBACSjB,KAAKN,QA3BHD,CAGHyB,iBChDH,ICQLC,EDRWxC,EAAiByC,0BCQ5BD,EDLqCxC,EAAe0C","file":"static/js/145.8c9edc29.chunk.js","sourcesContent":["// ** React Imports\nimport { useContext } from 'react'\n\n// ** Context\nimport { AbilityContext } from '@src/utility/context/Can'\n\n// ** Reactstrap Imports\nimport { Row, Col, Card, CardBody, CardTitle, CardText } from 'reactstrap'\n\nconst AccessControl = () => {\n  // ** Context\n  const ability = useContext(AbilityContext)\n  return (\n    <Row>\n      <Col md='6' sm='12'>\n        <Card>\n          <CardBody>\n            <CardTitle tag='h4'>Common</CardTitle>\n            <CardText>No ability is required to view this card</CardText>\n            <CardText className='text-primary'>This card is visible to 'user' and 'admin' both</CardText>\n          </CardBody>\n        </Card>\n      </Col>\n      {ability.can('read', 'Analytics') ? (\n        <Col md='6' sm='12'>\n          <Card>\n            <CardBody>\n              <CardTitle tag='h4'>Analytics</CardTitle>\n              <CardText>User with 'Analytics' subject's 'Read' ability can view this card</CardText>\n              <CardText className='text-danger'>This card is visible to 'admin' only</CardText>\n            </CardBody>\n          </Card>\n        </Col>\n      ) : null}\n    </Row>\n  )\n}\n\nexport default AccessControl\n","import { Children, ReactNodeArray, PureComponent, Fragment, createElement } from 'react';\nimport {\n  Unsubscribe,\n  AbilityTuple,\n  SubjectType,\n  AnyAbility,\n  Generics,\n  Abilities,\n  IfString,\n} from '@casl/ability';\n\nconst noop = () => {};\nconst renderChildren = Fragment\n  ? (children?: ReactNodeArray) => {\n    if (!children) {\n      return null;\n    }\n\n    return children.length > 1\n      ? createElement(Fragment, null, ...children)\n      : Children.only(children);\n  }\n  : Children.only;\n\ntype AbilityCanProps<\n  T extends Abilities,\n  Else = IfString<T, { do: T } | { I: T }>\n> = T extends AbilityTuple\n  ? { do: T[0], on: T[1], field?: string } |\n  { I: T[0], a: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], an: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], this: Exclude<T[1], SubjectType>, field?: string }\n  : Else;\n\ninterface ExtraProps {\n  not?: boolean\n  passThrough?: boolean\n}\n\ninterface CanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability: T\n}\n\ninterface BoundCanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability?: T\n}\n\nexport type CanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & CanExtraProps<T>;\nexport type BoundCanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & BoundCanExtraProps<T>;\n\nexport class Can<\n  T extends AnyAbility,\n  IsBound extends boolean = false\n> extends PureComponent<IsBound extends true ? BoundCanProps<T> : CanProps<T>> {\n  private _isAllowed: boolean = false;\n  private _ability: T | null = null;\n  private _unsubscribeFromAbility: Unsubscribe = noop;\n\n  componentWillUnmount() {\n    this._unsubscribeFromAbility();\n  }\n\n  private _connectToAbility(ability?: T) {\n    if (ability === this._ability) {\n      return;\n    }\n\n    this._unsubscribeFromAbility();\n    this._ability = null;\n\n    if (ability) {\n      this._ability = ability;\n      this._unsubscribeFromAbility = ability.on('updated', () => this.forceUpdate());\n    }\n  }\n\n  get allowed() {\n    return this._isAllowed;\n  }\n\n  private _canRender(): boolean {\n    const props: any = this.props;\n    const subject = props.of || props.a || props.an || props.this || props.on;\n    const can = props.not ? 'cannot' : 'can';\n\n    return props.ability[can](props.I || props.do, subject, props.field);\n  }\n\n  render() {\n    this._connectToAbility(this.props.ability);\n    this._isAllowed = this._canRender();\n    return this.props.passThrough || this._isAllowed ? this._renderChildren() : null;\n  }\n\n  private _renderChildren() {\n    const { children, ability } = this.props;\n    const elements = typeof children === 'function'\n      ? children(this._isAllowed, ability)\n      : children;\n\n    return renderChildren(elements);\n  }\n}\n","// ** Imports createContext function\nimport { createContext } from 'react'\n\n// ** Imports createContextualCan function\nimport { createContextualCan } from '@casl/react'\n\n// ** Create Context\nexport const AbilityContext = createContext()\n\n// ** Init Can Context\nexport const Can = createContextualCan(AbilityContext.Consumer)\n","import { createElement as h, ComponentClass, Consumer, StatelessComponent } from 'react';\nimport { AnyAbility } from '@casl/ability';\nimport { Can, BoundCanProps } from './Can';\n\ninterface BoundCanClass<T extends AnyAbility> extends ComponentClass<BoundCanProps<T>> {\n  new (props: BoundCanProps<T>, context?: any): Can<T, true>\n}\n\nexport function createCanBoundTo<T extends AnyAbility>(ability: T): BoundCanClass<T> {\n  return class extends Can<T, true> {\n    static defaultProps = { ability } as BoundCanClass<T>['defaultProps'];\n  };\n}\n\nexport function createContextualCan<T extends AnyAbility>(\n  Getter: Consumer<T>\n): StatelessComponent<BoundCanProps<T>> {\n  return (props: BoundCanProps<T>) => h(Getter, null, (ability: T) => h(Can, {\n    ability,\n    ...props,\n  } as any));\n}\n"],"sourceRoot":""}